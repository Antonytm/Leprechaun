<?xml version="1.0" encoding="utf-8" ?>

<leprechaun>
	<configurations>
		<configuration name="Lepresample.Base" abstract="true">
			<codeGenerator type="Leprechaun.CodeGen.Roslyn.CSharpScriptCodeGenerator, Leprechaun.CodeGen.Roslyn"
						   scripts="Synthesis.csx, Constants.csx, Diagnostics.csx"
						   rootNamespace="LeprechaunCodeGen.$(layer).$(module)"
						   outputFile="F:\Web\Leprechaun\src\Leprechaun.Console\bin\Debug\out\$(layer).$(module).Model.cs" />

			<dataStore physicalRootPath="F:\Web\legendary-pancake\src\$(layer)\$(module)\Items\Dev" />
		</configuration>

		<configuration name="Feature.Component" extends="Lepresample.Base">

		</configuration>

		<configuration name="Feature.Seo" extends="Lepresample.Base">

		</configuration>

		<configuration name="Feature.Navigation" extends="Lepresample.Base">

		</configuration>

		<configuration name="Project.Shared" extends="Lepresample.Base">

		</configuration>

		<configuration name="Foundation.Kernel" extends="Lepresample.Base">

		</configuration>

	</configurations>

	<!-- Config shared across all configurations -->
	<shared name="Shared">
		<metadataGenerator type="Leprechaun.MetadataGeneration.StandardTemplateMetadataGenerator, Leprechaun" singleInstance="true" />
		<architectureValidator type="Leprechaun.Validation.StandardArchitectureValidator, Leprechaun" singleInstance="true" />
		<architectureValidatorLogger type="Leprechaun.Validation.StandardArchitectureValidatorLogger, Leprechaun" singleInstance="true" />
		<logger type="Leprechaun.Console.ConsoleLogger, Leprechaun.Console" singleInstance="true" />
	</shared>

	<!-- Defaults all configurations inherit unless overridden -->
	<defaults>
		<!-- The data store defines where to find serialized items on disk. This should match Unicorn. -->
		<dataStore physicalRootPath=".\Unicorn\$(configurationName)" useDataCache="false" type="Rainbow.Storage.SerializationFileSystemDataStore, Rainbow" singleInstance="true"/>

		<!-- The template filter defines what items are included as templates from the data store -->
		<templateFilter type="Leprechaun.Filters.StandardTemplateFilter, Leprechaun" singleInstance="true">
			<include name="Templates" path="/sitecore/templates/$(layer)/$(module)" />
		</templateFilter>

		<fieldFilter type="Leprechaun.Filters.StandardFieldFilter, Leprechaun" singleInstance="true">
			<!-- 
				Excludes can either be field names (wildcards supported) or field IDs (e.g. <exclude fieldId="guid" />) 
				Note that these are TEMPLATE FIELD excludes (ignore on code generation), not excluding reading serialized item fields.
			-->
			<exclude name="__*" />
		</fieldFilter>

		<typeNameGenerator type="Leprechaun.MetadataGeneration.StandardTypeNameGenerator, Leprechaun" singleInstance="true" namespaceRootPath="/sitecore/templates/$(layer)/$(module)" />
		<templateReader type="Leprechaun.TemplateReaders.DataStoreTemplateReader, Leprechaun" singleInstance="true" />

		<!-- This should match up with the Unicorn/Rainbow configuration -->
		<serializationFormatter type="Rainbow.Storage.Yaml.YamlSerializationFormatter, Rainbow.Storage.Yaml" singleInstance="true">
			<fieldFormatter type="Rainbow.Formatting.FieldFormatters.MultilistFormatter, Rainbow" />
			<fieldFormatter type="Rainbow.Formatting.FieldFormatters.XmlFieldFormatter, Rainbow" />
			<fieldFormatter type="Rainbow.Formatting.FieldFormatters.CheckboxFieldFormatter, Rainbow" />
		</serializationFormatter>

		<!-- Tells Rainbow to let all fields that are serialized through; we do our own field filtering as we need to filter by template fields not items -->
		<rainbowFieldFilter type="Leprechaun.Filters.RainbowNullFieldFilter, Leprechaun" singleInstance="true" />

		<logger type="Leprechaun.Console.ConsoleLogger, Leprechaun.Console" singleInstance="true" />
	</defaults>
</leprechaun>